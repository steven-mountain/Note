CPU眼里的编程知识

### main 函数

```c++
// 相同两段代码
int main(){
    return 0;
}
int func(){
    return 0;
}
// 这两个函数的汇编指令完全相同

gcc -nostartfile -efunc test.c
```

+ CPU里函数没有主次之分，main函数的实现方法与普通函数完全一样
+ main函数是很多程序的默认起点，任何函数都可以被设置成程序的起点



### 变量

由于指令集的原因，CPU不可以直接访问内存，只能通过寄存器配合方括号，间接访问内存。

rip存放着CPU下一条指令的地址。

变量不过是内存地址的别名。

+ 每一个变量都对应了一个内存地址
+ 变量的类型决定了它占用内存空间的长度
+ 全局变量，静态变量对应的内存地址是全局唯一的，不会随程序的运行而变化。
+ 局部变量，也叫栈变量、临时变量。变量的值有 有效期 的限制。变量的地址也会因为不同的线程调用而不同。即使是同一个线程，也会因为调用轨迹的不同而不同。



### i++ vs ++i

  i++与++i的汇编指令相同，很多情况下二者没有任何区别。

如果是 

+ int a = ++i;  比后加少一个指令
+ int a = i++; 
  + 创建：临时变量 edx
  + 拷贝：临时变量给：变量i



后加（i++）的返回值是右值类型，右值的临时变量只能给别人赋值。

前加（++i）是左值的，可以直接赋值。

总结：

+ 通常前加与后加没有差异。但出现赋值的时候，前加会略快，但优势可以忽略不记。
+ 如果类型是类类型，那么二者差异就很大了。



### i++ 奇葩大挑战



### this 指针

从CPU的角度看，成员函数与普通函数是完全等价的。

this指针就是普通函数的参数。

**this指针是每一个成员函数必备的默认参数**，只是c++语法将其隐藏了。this指针就是生成对象的地址。

当对象调用成员函数时，都会把自己的地址当作this指针输入给成员函数。

c++23开始，this可以显示传递。





### 构造函数

**构造函数**与**成员函数**完全一致。隐藏参数this指针也是一样的。

在没有继承的情况下，构造函数与普通函数没有任何区别。

派生类的构造函数会夹带的调用基类的构造函数。如果存在虚函数，构造函数会记录虚函数表的地址。并保存在对象实例中。





### 虚函数

虚函数与普通函数是一样的，都会夹带this指针。区别在于调用的时候是否是静态绑定还是动态绑定。

当类A有虚函数的时候，类A会生成一个隐藏变量 `void* v ` 存放着虚函数表的地址，根据偏移就可以得到所需函数的地址。

**虚函数表**则是在调用**构造函数**的时候初始化的。



如果A有派生类B，这个隐藏变量V会在B的构造函数中被初始化为B的虚函数表地址。从而保证AB的虚函数相互独立。 

禁止在构造函数中，调用虚函数。



### 多态

CPU对多态是无感的。

+ 多态常会用基类指针指向派生类对象
+ 多态会利用派生类的结构特点，复用基类的属性。
+ 多态会利用虚函数来扩展派生类的特性。

派生类的空间会比基类大，（如果派生类有基类没有的成员变量），而如果把基类转换成派生类类型，则会出现内存访问越界的问题。



### 指针变量 | 数组指针 | 野指针

无论是什么类型的指针变量，对指针变量的**读写**跟普通变量没有任何区别。所谓的指向不过是在描述指针变量的值是多少而已。

+ 指针变量也是变量，读写操作跟普通变量完全一样。
+ 普通变量的值，多用于数学计算。而指针变量的值往往用于定位内存。
+ 指针变量的*操作，是对内存的读写操作，它可以改变变量的值。常量的值，CPU寄存器的值，还可以读写受保护的地址空间。
+ 而存在MMU的，会在读写收保护或非发地址时，爆出segmentation fault的错误，让程序立马崩溃。
+ 指针变量加减，是对内存地址的偏移。



### 指针 | 万物皆“指针”

变量读写都等同于对变量地址的指针*操作，

+ 指针操作不是指针变量的专利，普通变量甚至立即数也可以做指针操作
+ 计算机世界里，万物皆有地址，万物皆可指针。
+ 指针操作可以读写任意的内存地址，除了内存管理单元（MMU）没人能制止这些行为。

```c++
#include <iostream>
using namespace std;

class A{
private:
	int a;
public:
	int b;
	A(){
		a = 1;
		b = 2;
	}
	void show(){
		cout<<a<<endl;
	}
};

int main()
{
	A a;
	
   cout << *(&(a.b) - 1)<<endl; // 通过偏移拿到私有变量的地址
	*(&(a.b) - 1) = 2;
	a.show();
	// cout << (&(a.b) - &(a.a))<<endl;
   return 0;
}
```

