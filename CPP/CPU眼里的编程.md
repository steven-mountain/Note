CPU眼里的编程知识

### main 函数

```c++
// 相同两段代码
int main(){
    return 0;
}
int func(){
    return 0;
}
// 这两个函数的汇编指令完全相同

gcc -nostartfile -efunc test.c
```

+ CPU里函数没有主次之分，main函数的实现方法与普通函数完全一样
+ main函数是很多程序的默认起点，任何函数都可以被设置成程序的起点



### 变量

由于指令集的原因，CPU不可以直接访问内存，只能通过寄存器配合方括号，间接访问内存。

rip存放着CPU下一条指令的地址。

变量不过是内存地址的别名。

+ 每一个变量都对应了一个内存地址
+ 变量的类型决定了它占用内存空间的长度
+ 全局变量，静态变量对应的内存地址是全局唯一的，不会随程序的运行而变化。
+ 局部变量，也叫栈变量、临时变量。变量的值有 有效期 的限制。变量的地址也会因为不同的线程调用而不同。即使是同一个线程，也会因为调用轨迹的不同而不同。



### i++ vs ++i

  i++与++i的汇编指令相同，很多情况下二者没有任何区别。

如果是 

+ int a = ++i;  比后加少一个指令
+ int a = i++; 
  + 创建：临时变量 edx
  + 拷贝：临时变量给：变量i



后加（i++）的返回值是右值类型，右值的临时变量只能给别人赋值。

前加（++i）是左值的，可以直接赋值。

总结：

+ 通常前加与后加没有差异。但出现赋值的时候，前加会略快，但优势可以忽略不记。
+ 如果类型是类类型，那么二者差异就很大了。



### i++ 奇葩大挑战



### this 指针

从CPU的角度看，成员函数与普通函数是完全等价的。

this指针就是普通函数的参数。

**this指针是每一个成员函数必备的默认参数**，只是c++语法将其隐藏了。this指针就是生成对象的地址。

当对象调用成员函数时，都会把自己的地址当作this指针输入给成员函数。

c++23开始，this可以显示传递。





### 构造函数

**构造函数**与**成员函数**完全一致。隐藏参数this指针也是一样的。

在没有继承的情况下，构造函数与普通函数没有任何区别。

派生类的构造函数会夹带的调用基类的构造函数。如果存在虚函数，构造函数会记录虚函数表的地址。并保存在对象实例中。





### 虚函数

虚函数与普通函数是一样的，都会夹带this指针。区别在于调用的时候是否是静态绑定还是动态绑定。

当类A有虚函数的时候，类A会生成一个隐藏变量 `void* v ` 存放着虚函数表的地址，根据偏移就可以得到所需函数的地址。

**虚函数表**则是在调用**构造函数**的时候初始化的。



如果A有派生类B，这个隐藏变量V会在B的构造函数中被初始化为B的虚函数表地址。从而保证AB的虚函数相互独立。 

禁止在构造函数中，调用虚函数。



### 多态

CPU对多态是无感的。

+ 多态常会用基类指针指向派生类对象
+ 多态会利用派生类的结构特点，复用基类的属性。
+ 多态会利用虚函数来扩展派生类的特性。

派生类的空间会比基类大，（如果派生类有基类没有的成员变量），而如果把基类转换成派生类类型，则会出现内存访问越界的问题。



### 指针变量 | 数组指针 | 野指针

无论是什么类型的指针变量，对指针变量的**读写**跟普通变量没有任何区别。所谓的指向不过是在描述指针变量的值是多少而已。

+ 指针变量也是变量，读写操作跟普通变量完全一样。
+ 普通变量的值，多用于数学计算。而指针变量的值往往用于定位内存。
+ 指针变量的*操作，是对内存的读写操作，它可以改变变量的值。常量的值，CPU寄存器的值，还可以读写受保护的地址空间。
+ 而存在MMU的，会在读写收保护或非发地址时，爆出segmentation fault的错误，让程序立马崩溃。
+ 指针变量加减，是对内存地址的偏移。



### 指针 | 万物皆“指针”

变量读写都等同于对变量地址的指针*操作，

+ 指针操作不是指针变量的专利，普通变量甚至立即数也可以做指针操作
+ 计算机世界里，万物皆有地址，万物皆可指针。
+ 指针操作可以读写任意的内存地址，除了内存管理单元（MMU）没人能制止这些行为。

```c++
#include <iostream>
using namespace std;

class A{
private:
	int a;
public:
	int b;
	A(){
		a = 1;
		b = 2;
	}
	void show(){
		cout<<a<<endl;
	}
};

int main()
{
	A a;
	
   cout << *(&(a.b) - 1)<<endl; // 通过偏移拿到私有变量的地址
	*(&(a.b) - 1) = 2;
	a.show();
	// cout << (&(a.b) - &(a.a))<<endl;
   return 0;
}
```



### 参数传递 | 传值 vs 传指针 vs 传引用

+ 在CPU眼里没有传值、传指针的概念
+ 传递参数就是给寄存器赋值，寄存器是主调函数向被调函数输入参数的载体
+ CPU眼里也没有形式参数和实际参数的概念
+ 传引用和传指针的汇编是完全相同的



### 放弃：指针？ | 妙用：指针

+ 指针可以精确定位，避免了拷贝工作
+ 还可以访问硬件相关的寄存器
+ 指针对各种类型的兼容性非常好





### 数组（1D/2D/3D）

无论数据是一维的，二维的还是三维的，他们在内存中都是一段地址连续的一维内存



### 数组越界 | 堆栈溢出

```c++
void func(){
    long a[2];
    a[1] = 1;
    a[0] = 2;
    a[-1] = 3;
    a[-2] = 4;
}
// 这段代码竟然编译通过了
// 之所以没有问题，是因为越界元素所属的内存是一块无主之地，空闲的堆栈，不会影响到其他
```



+ 数组向高端地址越界，会修改堆栈中的关键数据，程序往往会立刻崩溃
+ 数组向低端地址越界，程序往往不会马上崩溃，但是与其他函数变量冲突时，其诡异行为绝对超出你的想象。



### 函数调用 | 调用栈回溯



### {函数括号} | 栈帧 | 堆栈 | 栈变量

保护栈帧，恢复栈帧不过是在保护和恢复寄存器 esp 和 ebp的值。

+ 操作系统会为每个任务分配：一段内存，当作任务堆栈

  CPU则提供两个寄存器 esp 和 ebp 用来标识当前函数对堆栈的使用情况。

  随着函数的调用，函数的栈帧会逐次堆叠，互不重合，随着函数的逐层返回，函数的栈帧会被就地放弃，但不会清理内存。

+ **{** 用来保护上层主调函数的栈帧，并设置被调函数的栈帧；**}**用来放弃被调函数的栈帧，同时恢复主调函数的栈帧。

+ ebp寄存器，作为当前函数的栈帧基地址，配合一定的偏移就可以读写函数体里的临时变量。

  如果一个变量是通过ebp寄存器间接访问的，那么它往往是临时变量。

+ 不同编译器对栈帧的实现方法略有不同，但思路一致。

关于 ebp和esp：

+ e - extended
+ sp：stack pointer（栈指针）
+ bp：base pointer（基指针）



### call vs return | 堆栈隐患

可以在函数中，通过局部变量地址的偏移，找到函数返回地址，对这个地址的值进行修改，既可以改变函数返回的行为。黑客入侵也是这样的方式。

这种方法简洁高效，但存在较大的安全隐患。



### 进程 vs 线程 | MMU系列

进程有空间独立性，如果没有MMU则就没有进程，因为MMU实现了内存空间的隔离。



### 内存映射 | 地址映射 | 页表 | MMU

+ MMU通过虚拟地址到物理地址的转换，该转换过程由MMU自动完成，CPU全程无感

+ 每个进程都有一张自己的页表，若它们的页表不同，则它们的进程空间是被隔离的。

  若相同或部分相同，则是在做进程间的内存共享。

  而线程没有独立的页表，它们共享同一个进程的页表，所以线程之间天生就可以内存共享

+ 分页不仅针对于物理地址，也试用于虚拟地址，它能有效的减少地址映射表的体量。

  页表里的值不仅可以是真实的内存地址，也可以是硬盘上的扇区信息。在内存不够用的时候，也可以用硬盘来补位。



### 虚拟内存

计算机位数（决定所能寻址的空间大小）也就决定了虚拟内存的大小。这里也就是操作系统课里讲的了。

