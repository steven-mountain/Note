vulkan术语



### 1、glfw 与 vulkan

`glfwGetRequiredInstanceExtensions`，获取glfw所需要的vulkan instance 拓展，glfw以次来创建窗口



### 2、Feature与Properties

"特性"（Features）和"属性"（Properties）是用来描述显卡（GPU）支持的**功能**和特定的**硬件参数**的两个不同概念。

在实际的 Vulkan 开发过程中，通常会**先查询物理设备的属性**，以选择合适的设备，**然后查询该设备支持的特性**，最后在**创建逻辑设备**时**启用所需的特性**。



**特性 (Features)**

特性通常指的是 GPU 支持的**可选的高级功能**，这些功能不是所有的 GPU 都支持。开发者可以通过查询特定的特性来决定是否使用某些高级图形技术或优化路径。如果一个应用程序依赖于某个特定的特性，那么在该特性不被支持的 GPU 上，应用程序可能需要降级其功能或以不同的方式实现。

例如，一些高级的纹理压缩格式、几何着色器、多视口渲染等功能，就是通过查询 GPU 的特性来决定是否可用的。在 Vulkan 中，你可以通过填充 `VkPhysicalDeviceFeatures` 结构体并使用 `vkGetPhysicalDeviceFeatures` 函数来查询这些支持的特性。

例如：

`VkPhysicalDeviceAccelerationStructureFeaturesKHR` 结构体则描述了物理设备支持的与加速结构相关的特性。这些特性表明了**设备是否支持某些光线追踪功能**，例如**加速结构的更新、加速结构的复制等**。通过查询这些特性，开发者可以确定在当前设备上哪些高级光线追踪功能是可用的，并据此启用或禁用特定的渲染路径或优化。



**属性 (Properties)**

属性则提供了关于 **GPU 和其内存的更具体的信息**，如供应商 ID、设备名称、内存大小等。属性不像特性那样表示可选的高级功能，而是提供了**关于硬件和驱动程序**的基本信息，这些信息可以帮助应用程序更好地理解它正在运行的平台，并根据这些信息做出适当的优化决策。

你可以通过填充特定的结构体（如 `VkPhysicalDeviceProperties`）并使用 `vkGetPhysicalDeviceProperties` 函数来获取 GPU 的属性信息。

例如：

`VkPhysicalDeviceAccelerationStructurePropertiesKHR` 结构体提供了有关物**理设备加速结构支持的具体属性信息**。这包括了一些关键的硬件限制，如**最大的几何体数量、实例数量、加速结构的最大大小等**。了解这些属性对于开发者在创建和管理加速结构时，能够根据硬件的能力来优化它们的使用是非常重要的。



**总结**

简而言之，**特性（Features）表示 GPU 支持的高级功能**，这些功能可能对某些应用程序的高级图形技术至关重要，而**属性（Properties）提供了关于 GPU 的基础信息**，如性能指标、硬件规格等。正确地查询和利用这些信息对于开发高性能、跨平台的 Vulkan 应用程序非常重要。



我们说启动**拓展**，其实就是查询硬件是否支持某些**特性**。



### 3、InstanceExtension 与 DeviceExtension的区别

扩展（Extensions）提供了**额外的功能**，这些功能并不包含在核心 Vulkan 规范中。扩展可以由显卡供应商、Khronos Group（Vulkan 的维护组织）或其他第三方提供。Vulkan 扩展分为两大类：**实例扩展**（Instance Extensions）和**设备扩展**（Device Extensions）。它们的主要区别在于**作用范围**和**使用的上下文**。

**实例扩展（Instance Extensions）**

- **作用范围**：实例扩展影响的是 Vulkan 实例的创建和**整个实例**的行为。Vulkan 实例是与**应用程序关联**的 Vulkan 的高级抽象，它是使用 Vulkan 进行绘制的入口点。
- **使用场景**：实例扩展通常用于**扩展 Vulkan 实例的功能**，如提供对新的表面类型的支持（用于显示输出的表面），或者增强调试和分层功能等。实例扩展不直接影响特定的 GPU 设备或渲染操作。
- **查询和启用**：在创建 Vulkan 实例时查询和启用实例扩展。你需要在调用 `vkCreateInstance` 之前查询支持的实例扩展，并在实例创建时指定要启用的实例扩展。

**设备扩展（Device Extensions）**

- **作用范围**：设备扩展影响的是**特定的物理设备（显卡）**及其队列和命令缓冲区的行为。设备扩展提供了对特定硬件功能的访问，这些功能可能并不是所有的硬件都支持。
- **使用场景**：设备扩展用于添加特定于**设备的功能**，如光线追踪、特定的图像格式支持，或者其他高级渲染技术等。这些扩展通常提供了对硬件特定功能的访问，使得开发者能够充分利用其显卡的高级功能。
- **查询和启用**：在创建逻辑设备时查询和启用设备扩展。你需要首先查询特定物理设备支持的设备扩展列表，然后在**创建逻辑设备**（`vkCreateDevice`）时指定要启用的设备扩展。

**总结**

实例扩展和设备扩展的主要区别在于它们的**作用范围和影响对象**：**实例扩展影响整个 Vulkan 实例的行为**，而**设备扩展提供了对特定硬件功能的访问**。在开发 Vulkan 应用程序时，根据应用程序的需求和目标硬件的支持情况，合理地查询和启用相应的扩展是很重要的。



### 4、VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME

`VK_KHR_deferred_host_operations` 是 Vulkan 的一个扩展，而 `VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME` 是这个扩展的名称字符串常量。这个扩展提供了一种机制，**允许某些操作在主机（CPU）上异步地执行**，而不是立即完成。这主要用于支持其他需要大量异步主机工作的扩展，比如光线追踪或者某些复杂的计算任务。**这样可以避免阻塞主线程，提高应用程序的响应性和性能。**

之所以是deviceExtension，因为它提供的功能和特性是针对**特定物理设备**（GPU）的。这个扩展允许对那些可能需要大量异步主机工作的设备级操作进行优化和异步处理，这些操作和设备的具体能力密切相关。



### 5、如何使用拓展的函数

如果扩展已经被启用，则可以使用 `vkGetInstanceProcAddr` 或 `vkGetDeviceProcAddr` 获取或拓展功能和某些平台特定的函数的地址



### 6、命令缓冲区的静态性

当你记录一个 Command Buffer 时，你在**定义一系列将要执行的 GPU 命令**。这些命令通常包括绘制调用、资源绑定等，而**这个阶段并不执行任何实际的计算或数据处理**。这意味着，**在记录 Command Buffer 时，并不能执行任何 CPU 端的计算逻辑来动态更新 UBO。**



ChatGPT的解释：

在 Vulkan 中，当你在命令缓冲区中绑定一个 UBO 到管线，你实际上是告诉 GPU：“**在执行这个命令缓冲区时，使用这个特定的 UBO。**” 如果你在命令缓冲区记录之前更新了 UBO 的内容，并且在记录命令缓冲区时绑定了这个 UBO，那么 `vkCmdDraw` 命令确实会使用更新后的 UBO 内容。**这里的关键是更新和绑定操作需要在命令缓冲区被提交执行之前完成。**

在 Vulkan 中，通常我们指的是在命令缓冲区记录之外对资源进行更新，然后在需要时将更新后的资源绑定到命令缓冲区。这种方式确保了资源更新是可控和同步的。如果尝试在命令缓冲区记录*过程中*（比如在一系列 `vkCmd*` 调用之间）直接更新 UBO 的内容，就会面临同步和一致性问题，因为 **Vulkan 不保证这种类型的“即时”更新何时对 GPU 可见**。



ps：我的理解是，由于GPU并不保证commandbuffer里记录的指令按顺序执行，因此也就不能保证在draw之前的更新是可行的。关键是要**理解CPU和GPU之间的明确区分和协作**。



**KEY：**通过对CHATGPT的拷打，我感觉我悟道了，终于知道什么是命令缓冲区的静态性了，以及为什么在命令缓冲区中"嵌入"CPU命令是不可行的。 以下是chatgpt的原话：

如果在记录命令缓冲区的代码中出现了 CPU 操作（如直接更新 UBO），Vulkan 并不会将这些 CPU 操作“记录”到命令缓冲区中。相反，**这些 CPU 操作在命令缓冲区被记录时就已经执行了**，而且**它们的效果（例如 UBO 的更新）需要在 GPU 开始处理命令缓冲区之前就完成**。

Vulkan 要求开发者**显式管理 CPU 和 GPU 之间的交互**，包括资源更新和同步。这意味着开发者需要确保在命令缓冲区执行相关 GPU 指令之前，所有必要的 CPU 操作（如资源更新）已经完成，并通过 Vulkan 的同步机制确保正确的执行顺序和资源状态。

所以啥叫静态性，就是CPU和GPU各干各的，减少这两者的交互，因为这很昂贵。



### 7、vulkan GPU内的执行顺序

理解 GPU 如何执行命令缓冲区中的命令时，需要注意两个层面的“顺序”：

1. **编程接口层面的顺序**：在 Vulkan（以及其他类似的底层图形 API 中）中，命令缓冲区内的命令确实是**按照它们被记录的顺序提交给 GPU 的**。这意味着，从编程模型的角度看，你可以期望命令按照记录的顺序执行。
2. **硬件执行层面的顺序**：尽管命令是按顺序提交的，但 GPU 可能并不总是严格按照这个顺序执行它们。GPU 设计为高度并行的处理器，它**可能会重排一些操作或同时执行多个操作**，以优化性能和资源利用率。这种优化是在**不违反数据依赖性的前提**下进行的。比如，如果两个绘制调用之间没有直接的数据依赖关系，GPU 可能会选择并行执行它们。

command buffer记录的是 `vkCmd*`的命令。



### 8、gl_InstanceID和gl_InstanceCustomIndex

+ gl_InstanceID

`gl_InstanceID` 是一个在图形和计算管线中广泛使用的**内置变量**。在图形管线的顶点着色器中，`gl_InstanceID` 提供了当前实例的索引，这对于实例化渲染非常有用。**实例化渲染**允许你用不同的参数（如变换矩阵）多次绘制相同的几何体，每次绘制称为一个“实例”。`gl_InstanceID` 从 0 开始，为每个实例提供了一个唯一的索引，使着色器能够根据实例索引访问实例特定的数据，如不同的变换矩阵。

+ gl_InstanceCustomIndex

`gl_InstanceCustomIndex` 是在 **Vulkan 射线追踪管线中引入的一个新的内置变量**。当执行射线追踪时，`gl_InstanceCustomIndex` 提供了与当前相交的 `VkAccelerationStructureInstanceKHR` 相关联的**自定义索引值**。这个自定义索引值是在构建顶层加速结构（TLAS）时，通过 `VkAccelerationStructureInstanceKHR` 结构体中的 `instanceCustomIndex` 字段指定的。`gl_InstanceCustomIndex` 允许你在着色器中根据每个实例的自定义索引执行不同的逻辑，比如使用不同的材质或处理不同类型的对象。

+ 区别

  - **使用上下文**：`gl_InstanceID` 主要用于**传统的图形管线中的实例化**渲染，而 `gl_InstanceCustomIndex` 专门用于 Vulkan 射线追踪管线。

  - **值的来源**：`gl_InstanceID` 是**由渲染管线自动生成**的，表示实例的索引；`gl_InstanceCustomIndex` 则由开发者在构建 TLAS 时通过 `VkAccelerationStructureInstanceKHR` **明确指定**。

  - **用途**：`gl_InstanceID` 通常用于**访问每个实例的特定资源**，如实例化数组中的变换矩阵；`gl_InstanceCustomIndex` 则用于射线追踪中**根据实例执行特定的着色逻辑**，这可以基于构建 TLAS 时分配给实例的自定义值。



### 9、图像作为输出目标

在传统光栅化中，一般将输出图像（写入目标）通过render pass的**attachment**在framebuffer中与对应的图像绑定。

但是在光追或者计算着色器中，通常不使用传统的render pass来处理图像。

+ 灵活：描述符允许图像在不同着色器和管线之间共享和访问，包括计算着色器和光线追踪着色器。
+ 支持更广泛的操作：通过描述符，着色器可以对图像执行更复杂的读写操作，如在计算着色器中进行图像处理或数据分析。



在 Vulkan 中，当使用**图像作为输出目标**时，即作为着色器写入目标而不是作为纹理读取源时，你通常**不需要为该图像配置采样器**（sampler）。这是因为采样器主要用于定义图像数据如何被读取和采样（如过滤、坐标变换等），而在直接写入图像的场景中，这些操作不适用。



### 10、storage与uniform

在 Vulkan 中，`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` 和 `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` 都用于将数据传递给着色器，但它们在支持数据访问方式上存在一些差异。

`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`

- **访问方式**：`uniform buffer` 主要用于存储小规模的统一数据，如变换矩阵、光照参数等，这些数据在着色器中通常是按需顺序访问的。尽管技术上可以实现非顺序访问，但 `uniform buffer` 通常不用于这种目的，主要因为它的设计优化是针对快速访问相对较小和经常使用的数据集。
- **访问模式**：在着色器中，对 `uniform buffer` 的访问通常是只读的，并且经过优化以快速获取数据。

`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`

- **访问方式**：`storage buffer` 提供了更大的灵活性，支持从着色器中进行非顺序的、任意的读写操作。这使得 `storage buffer` 非常适合处理复杂的数据结构，如顶点数据、粒子系统状态或其他大规模数据集，这些可能需要在着色器执行期间被更新或其访问模式不是严格顺序的。
- **访问模式**：`storage buffer` 支持从着色器中读取和写入数据，允许进行更复杂的计算和数据处理。

结论

总的来说，

+ 如果你的应用场景需要着色器**以非顺序方式访问大量数据**，并且可能包括写操作，`storage buffer` 是更合适的选择。

+ 而 `uniform buffer` 适用于那些**数据规模较小且访问模式相对固定**（通常是顺序访问）的情况。选择正确的缓冲区类型对于优化应用性能和资源利用率至关重要。

