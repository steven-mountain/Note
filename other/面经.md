## 面经

### C++

#### 1、多态

+ 静态多态（编译时多态）

  编译器在编译阶段就能确定调用哪个函数或使用哪个模板实例。

  + 模板

    模板允许你编写**依赖于参数的代码**。模板在实例化时，编译器根据提供的**类型参数生成具体的类型或函数**。

  + 函数重载

    在同一个作用域内，可以声明多个**名称相同但是参数列表**不同的函数。根据传递给函数的参数类型和数量，编译器决定调用哪个函数。

+ 动态多态（运行时多态）

  运行时多态主要是通过**虚函数**（virtual function）和**继承**实现的。这允许在**运行时根据对象的实际类型来调用相应的成员函数**，而不是在编译时。

  + 虚函数

    在基类中使用`virtual`关键字声明的函数。如果**派生类**提供了虚函数的一个新实现（即**重写了基类的虚函数**），那么通过**基类指针或引用**调用该**虚函数**时，会根据对象的**实际类型调用相应的函数实现**。

  + 虚继承

    在基类中声明虚函数时，可以将其定义为`= 0`，这表示函数没有实现（即**纯虚函数**）。包含纯虚函数的类称为**抽象基类**，**不能直接实例化**。纯虚函数的主要目的是**定义接口规范**，强制派生类实现该接口。



#### 2、虚函数表

 + 1、编译器为每一个类维护一个虚函数表，每个对象的**首地址保存着该虚函数表的指针**，同一个类的不同对象实际上指向同一张虚函数表。

 + 2、当一个对象包含虚函数的时候，这个类内存首地址包含虚指针，也就是说，一个对象只要有**虚指针**，其内存所占大小至少是**4字节**以上。

 + 3、构造函数和析构函数能不能是虚函数？

   **构造函数不能为虚函数**，在构造过程是这样的，**首先分配一块内存，然后调用构造函数**。如果构造函数是虚函数，那么就需要虚函数表来调用，此时面对一块新鲜出炉的内存，去哪找虚函数表呢？因此构造函数不能为虚函数。

   **析构函数相反**，通常我们通过基类指针销毁对象时，如果析构函数不为虚函数，就不能**正确识别对象类型**，从而不能正确销毁对象，带来可能的内存泄漏问题。

 + 4、函数指针如何访问虚函数表

   通过调用对象的虚函数表指针(vptr)间接访问虚函数表。



#### 3、STL容器

+ 常见容器：vector、deque、priority_queue、set/map、unordered_set/map

+ 序列容器、关联容器、无序关联容器和容器适配器。

+ **vector** 底层使用的是**连续的内存空间**来存储元素，就像一个普通的数组，维护三个指针

  + **开始指针**：指向数组的第一个元素。
  + **结束指针**：指向数组中最后一个元素之后的位置，也就是第一个无效元素的位置。
  + **容量末尾指针**：指向分配的内存空间的末尾，这定义了 `vector` 可以在不重新分配内存的情况下存储多少元素。

  计算新容量，通常是当前容量的两倍（具体可能不同），分配新内存，释放旧内存，更新指针。

+ `priority_queue` 的底层是以堆（通常是最大堆或最小堆）的形式实现的，而**堆本身通常使用连续的内存空间**（如数组或 `vector`）来表示。

  插入元素，都是放在最底层，然后再与其父节点比较



#### 4、智能指针

智能指针

+ **`std::unique_ptr`**: 它是**一种独占所有权的智能指针**，确保同一时间只有一个`unique_ptr`可以指向一个给定的资源。当`unique_ptr`离开作用域时，它所指向的资源会被自动释放。**它不允许复制，确保了资源的唯一所有权，但可以进行移动操作**，将资源所有权从一个`unique_ptr`转移到另一个。

+ **`std::shared_ptr`**: 它是一种**共享所有权**的智能指针，允许多个`shared_ptr`实例**指向同一个资源**。`shared_ptr`使用引用计数机制来跟踪有多少个`shared_ptr`指向同一个资源。当**最后一个指向**该资源的`shared_ptr`被**销毁或重新指向其他资源时**，**原始资源将被释放**。这种机制使得资源管理变得简单，但也增加了一些开销。

+ **`std::weak_ptr`**: 它是一种配合`std::shared_ptr`使用的智能指针，不增加引用计数。它用来解决`std::shared_ptr`可能导致的循环引用问题。通过`weak_ptr`，**可以观察但不拥有资源，当资源被释放时，所有指向它的`weak_ptr`将自动变为空。**

实现机制

- **`std::unique_ptr`** 通常通过构造函数和析构函数来实现其**管理内存**的功能。**构造函数接管一个裸指针，而析构函数负责调用`delete`来释放这个裸指针**指向的内存。移动语义通过移动构造函数和移动赋值操作符来实现，它们传递所有权并将原始指针置为`nullptr`。
- **`std::shared_ptr`** 的实现更为复杂，因为它涉及到引用计数。除了管理资源的指针外，`shared_ptr`还维护了一个**引用计数器**，通常是通过一个**控制块**来实现的。每当一个新的`shared_ptr`被**创建或赋值**为指向相同资源的另一个`shared_ptr`时，这个资源的引用计数就会**增加**。当`shared_ptr`被**销毁或重新**指向其他资源时，引用计数就会**减少**。当**引用计数归零时，资源会被释放**。

循环引用发生在两个或多个`std::shared_ptr`实例相互引用，形成一个闭环。在这种情况下，即使这些`std::shared_ptr`实例已经不再被任何外部引用，它们所指向的对象的引用计数也不会降到0，因为它们互相持有对方，导致对象无法被释放，从而引发内存泄露。



#### 5、extern、static、const关键字

`extern`、`static`和`const`是C和C++中的三个重要关键字，它们分别用于声明变量或函数的**链接性、存储期和修改权限**。理解它们的用法对编写高质量的代码至关重要。

+ `extern`关键字用于声明一个变量或函数是在另一个文件或本文件的其他地方定义的。它用来在**多个文件之间共享变量或函数**。当你在一个文件中声明一个`extern`变量时，你告诉编译器这个**变量的定义在别的地方**，链接器会在所有的编译单元中寻找这个变量的定义。
+ `static`关键字有多种用途，但主要用于改变变量的存储期和链接性。
  - 在**函数内部**使用`static`声明的变量，其**生命周期**为整个程序执行期间，但只在声明它的**函数内可见**。这意味着该变量的值在函数调用之间保持不变，但在函数外部不可见。
  - 在函数**外**部使用`static`声明的**全局变量或函数**，会使其链接性变为**内部链接性**（仅限当前文件可见），这有助于避免不同文件间的命名冲突。

+ `const`关键字用于声明变量的值不可修改。一旦变量被`const`修饰并初始化之后，其值就不能被改变。这对于定义不变的常量非常有用。

ps: 在同一声明中同时使用`extern`和`static`是矛盾的，因为`extern`指示变量或函数可以在**其他文件**中访问，而`static`（在文件级别变量或函数上使用时）限制了访问范围，使之**仅在定义它的文件**内可见。



#### 6、C++的内存分配

+ 栈（stack）：又称堆栈，栈是由编译器自动分配释放，存放函数的参数值，局部变量的值等（但不包括static声明的变量，static意味着在数据段中存放变量）。除此之外，在函数被调用时，栈用来传递参数和返回值。由于栈的先进后出的特点，所以栈特别方便用来保存/恢复调用数据。其操作方式类似于数据结构中的栈。
+ 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小，并不固定，可动态扩张或缩放。当进程调用malloc/free等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）/释放的内存从堆中被提出（堆被缩减）。堆一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
+ **全局数据区（静态区）**（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域。
+ 文字常量区：常量字符串就是放在这里，程序结束后由系统释放。
+ 程序代码区：存放函数体的二进制代码

C语言在编译和连接后，将分成**代码段**(Text)、**只读数据段**(ROData)和**读写数据段**(RWData)。在运行时，除了以上三个区域外，还包括未初始化数据段(BSS)区域和堆(Heap)区域和栈(Stack)区域。



### 图形学八股

#### 1、渲染管线

(1). 渲染管线就是**一堆原始图形数据经过各种变化处理最终出现在屏幕的过程。**渲染管线可分为三个阶段，**应用程序阶段，几何阶段，和光栅化阶段**

**(2). 应用程序阶段**由CPU主要负责。CPU将GPU渲染需要的灯光、模型准备好，并设置好渲染状态，为GPU渲染做好准备。

**(3). 几何阶段**把输入的3D数据转换成2D数据。包括**顶点着色器、图元装置、裁剪和屏幕映射**几个过程。**顶点着色器**主要进行**顶点坐标变换**。将输入的**模型空间**顶点坐标变换到**裁剪空间**顶点坐标**。图元装配**将**顶点**装配成指定**图元**的形状。**几何着色器**改变图元。通过产生新顶点构造出新的图元来生成其他形状。

裁剪：通过透视投影后的顶点处于标准立方体中；屏幕映射阶段：它将处于NDC空间图元的3D顶点的xy坐标转换到**屏幕坐标系(Screen Space)**下

**(4). 光栅化阶段**把图元映射为最终屏幕上显示的颜色。包括**光栅化**，**片段着色，深度测试和混合。光栅化将**顶点转为屏幕上的像素。**片段着色器**计算每个像素的最终颜色。**深度测试**通过深度信息判断像素的**遮挡关系。混合阶段**通过**透明度**将像素进行混合。

(5). 最终渲染好的颜色先被送入后置缓冲，随后再替换前置缓冲，显示在屏幕上

作者：CarlHer
链接：https://zhuanlan.zhihu.com/p/575930904
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



#### 2、渲染方程



#### 3、brdf







## C++基础知识

### 序列容器

序列容器按照严格的线性顺序存储元素。

- **`vector`**：表示可变大小的数组。支持快速随机访问，尾部添加/删除元素也非常高效，但在中间或头部插入/删除元素可能较慢。
- **`deque`**：双端队列，支持从头部和尾部高效地添加/删除元素。随机访问也很快速，但比`vector`慢。
- **`list`**：双向链表，支持在任何位置高效地插入和删除元素，但不支持快速随机访问。
- **`forward_list`**（C++11）：单向链表，与`list`类似，但只支持单向顺序访问，性能上比`list`更优，但功能较少。

### 关联容器

关联容器根据**键**来存储元素，支持快速的查找操作。

- **`set`**：集合，包含唯一键的集合，元素会按照键的顺序排序。
- **`multiset`**：多重集合，允许键值重复的集合，元素也会按照键的顺序排序。
- **`map`**：映射，包含“键-值”对，每个键只能出现一次，元素按照键的顺序排序。
- **`multimap`**：多重映射，允许键重复的映射，元素按照键的顺序排序。

### 无序关联容器（C++11）

基于**哈希表**实现，提供快速的访问能力。

- **`unordered_set`**：无序集合，包含唯一键的集合，元素无序存储。
- **`unordered_multiset`**：无序多重集合，允许键值重复，元素无序存储。
- **`unordered_map`**：无序映射，包含“键-值”对，每个键唯一，元素无序存储。
- **`unordered_multimap`**：无序多重映射，允许键重复，元素无序存储。

### 容器适配器

容器适配器提供了一种修改容器接口的方式，使其提供不同的功能。

- **`stack`**：栈，提供后进先出(LIFO)的数据结构。
- **`queue`**：队列，提供先进先出(FIFO)的数据结构。
- **`priority_queue`**：优先队列，元素按优先级出队，内部通常使用堆来实现。

+ priority_queue：
  + **大顶堆 ：每个结点的值都大于或等于其左右孩子结点的值。** 最小 K 个数
  + **小顶堆 ：每个结点的值都小于或等于其左右孩子结点的值** 最大 K 个数